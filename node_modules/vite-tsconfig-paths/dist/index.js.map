{"version":3,"sources":["../src/index.ts","../src/debug.ts","../src/mappings.ts","../src/path.ts","../src/logFile.ts"],"sourcesContent":["import * as fs from 'node:fs'\nimport { readdir } from 'node:fs/promises'\nimport globRex from 'globrex'\nimport * as tsconfck from 'tsconfck'\nimport { isAbsolute, join, relative } from 'node:path'\nimport { inspect } from 'node:util'\nimport * as vite from 'vite'\nimport { debug } from './debug'\nimport { resolvePathMappings } from './mappings'\nimport type { NormalizedPath } from './path'\nimport * as path from './path'\nimport {\n  Directory,\n  PluginOptions,\n  Project,\n  Resolver,\n  ViteResolve,\n} from './types'\nimport { createLogFile } from './logFile'\n\nconst notApplicable = [undefined, false] as const\nconst notFound = [undefined, true] as const\n\n/** A directory with no projects. */\nconst emptyDirectory: Directory = {\n  projects: Object.freeze([]) as any,\n  lazyDiscovery: false,\n}\n\nexport type { PluginOptions }\n\nexport default (opts: PluginOptions = {}) => {\n  let projectRoot: NormalizedPath\n  let workspaceRoot: NormalizedPath\n  let hasTypeScriptDep: boolean\n  let processConfigFile: (\n    dir: NormalizedPath,\n    name: string,\n    data?: Directory\n  ) => Promise<void>\n  let invalidateConfigFile: (\n    dir: NormalizedPath,\n    name: string,\n    event: 'change' | 'unlink'\n  ) => void\n  let getResolvers: (importer: string) => AsyncIterable<Resolver> =\n    async function* () {}\n  let watcher: vite.FSWatcher | undefined\n  let viteLogger: vite.Logger\n  let directoryCache: Map<string, Directory>\n  let resolversByProject: WeakMap<Project, Resolver>\n\n  const configNames = opts.configNames || ['tsconfig.json', 'jsconfig.json']\n  debug(\n    'Only tsconfig files with a name in this list will be lazily discovered:',\n    configNames\n  )\n\n  const logFile = opts.logFile\n    ? createLogFile(\n        opts.logFile === true ? 'vite-tsconfig-paths.log' : opts.logFile\n      )\n    : null\n\n  const plugin = {\n    name: 'vite-tsconfig-paths',\n    enforce: 'pre',\n    configResolved(config: Pick<vite.ResolvedConfig, 'logger' | 'root'>) {\n      viteLogger = config.logger\n\n      let { root } = opts\n      if (root) {\n        root = projectRoot = workspaceRoot = path.resolve(config.root, root)\n        debug('Forced root:', root)\n      } else {\n        projectRoot = path.normalize(config.root)\n        workspaceRoot = path.normalize(vite.searchForWorkspaceRoot(config.root))\n        debug('Project root:  ', projectRoot)\n        debug('Workspace root:', workspaceRoot)\n      }\n\n      hasTypeScriptDep = false\n      if (opts.parseNative) {\n        try {\n          const pkgJson = fs.readFileSync(\n            join(workspaceRoot, 'package.json'),\n            'utf8'\n          )\n          const pkg = JSON.parse(pkgJson)\n          const deps = { ...pkg.dependencies, ...pkg.devDependencies }\n          hasTypeScriptDep = 'typescript' in deps\n        } catch (e: any) {\n          if (e.code != 'ENOENT') {\n            throw e\n          }\n        }\n      }\n    },\n    async buildStart() {\n      directoryCache = new Map()\n      resolversByProject = new WeakMap()\n\n      let isFirstParseError = true\n\n      const parseProject = async (\n        tsconfigFile: string\n      ): Promise<Project | null> => {\n        tsconfigFile = path.normalize(tsconfigFile)\n\n        try {\n          return (\n            hasTypeScriptDep\n              ? await tsconfck.parseNative(tsconfigFile)\n              : await tsconfck.parse(tsconfigFile)\n          ) as Project\n        } catch (error: any) {\n          if (opts.ignoreConfigErrors) {\n            debug('[!] Failed to parse tsconfig file at %s', tsconfigFile)\n            if (isFirstParseError) {\n              debug('Remove the `ignoreConfigErrors` option to see the error.')\n            }\n          } else {\n            viteLogger.error(\n              '[tsconfig-paths] An error occurred while parsing \"' +\n                tsconfigFile +\n                '\". See below for details.' +\n                (isFirstParseError\n                  ? ' To disable this message, set the `ignoreConfigErrors` option to true.'\n                  : ''),\n              { error }\n            )\n            if (!viteLogger.hasErrorLogged(error)) {\n              console.error(error)\n            }\n          }\n          isFirstParseError = false\n          return null\n        }\n      }\n\n      const addProject = (project: Project, data?: Directory) => {\n        const tsconfigFile = project.tsconfigFile\n        const dir = path.normalize(path.dirname(tsconfigFile))\n        data ??= directoryCache.get(dir)\n\n        // Sanity check\n        if (data?.projects.some((p) => p.tsconfigFile === tsconfigFile)) {\n          return\n        }\n\n        if (watcher) {\n          watcher.add(tsconfigFile)\n          project.extended?.forEach((parent) => {\n            watcher!.add(parent.tsconfigFile)\n          })\n        }\n\n        // Referenced projects must be added first, so they can override\n        // the parent project's paths if both are in the same directory.\n        if (project.referenced) {\n          project.referenced.forEach((projectRef) => {\n            addProject(projectRef)\n          })\n          // Ensure the latest directory data is used. One of the project\n          // references may have updated it.\n          data = directoryCache.get(dir)\n        }\n\n        const resolver = createResolver(project)\n        if (resolver) {\n          resolversByProject.set(project, resolver)\n        }\n\n        if (!data || data === emptyDirectory) {\n          directoryCache.set(\n            dir,\n            (data = {\n              projects: [],\n              lazyDiscovery: null,\n            })\n          )\n        }\n\n        data.projects.push(project)\n      }\n\n      const loadProject = async (tsconfigFile: string, data?: Directory) => {\n        const project = await parseProject(tsconfigFile)\n        if (project) {\n          addProject(project, data)\n        } else {\n          // Try again if the file changes.\n          watcher?.add(tsconfigFile)\n        }\n      }\n\n      // Ensure a deterministic order.\n      const sortProjects = (projects: Project[]) => {\n        projects.sort((left, right) =>\n          left.tsconfigFile.localeCompare(right.tsconfigFile)\n        )\n      }\n\n      processConfigFile = async (dir, name, data = directoryCache.get(dir)) => {\n        if (!data) {\n          return // Wait to be loaded on-demand.\n        }\n        const file = path.join(dir, name as NormalizedPath)\n        if (data.projects.some((p) => p.tsconfigFile === file)) {\n          return\n        }\n        await loadProject(file, data)\n      }\n\n      invalidateConfigFile = (dir, name, event) => {\n        const data = directoryCache.get(dir)\n        if (!data) {\n          return\n        }\n        const file = path.join(dir, name as NormalizedPath)\n        const index = data.projects.findIndex(\n          (project) => project.tsconfigFile === file\n        )\n        if (index !== -1) {\n          const project = data.projects[index]\n          debug(\n            `Unloading project because of ${event} event:`,\n            project.tsconfigFile\n          )\n\n          resolversByProject.delete(project)\n          data.projects.splice(index, 1)\n\n          if (event === 'change') {\n            if (opts.projectDiscovery === 'lazy') {\n              data.lazyDiscovery = null\n            } else {\n              loadProject(project.tsconfigFile, data)\n                .then(() => {\n                  sortProjects(data.projects)\n                })\n                .catch(console.error)\n            }\n          }\n        }\n      }\n\n      const shouldSkipDir = (dir: string) => {\n        if (dir === '.git' || dir === 'node_modules') {\n          return true\n        }\n        if (typeof opts.skip === 'function') {\n          return opts.skip(dir)\n        }\n        return false\n      }\n\n      if (opts.projects || opts.projectDiscovery !== 'lazy') {\n        const projectPaths =\n          opts.projects?.map((file) => {\n            if (!file.endsWith('.json')) {\n              file = join(file, 'tsconfig.json')\n            }\n            return path.resolve(projectRoot, file)\n          }) ??\n          (await tsconfck.findAll(workspaceRoot, {\n            configNames,\n            skip: shouldSkipDir,\n          }))\n\n        debug('Eagerly parsing these projects:', projectPaths)\n\n        await Promise.all(\n          Array.from(new Set(projectPaths), (p) => loadProject(p))\n        )\n        for (const data of directoryCache.values()) {\n          sortProjects(data.projects)\n        }\n      }\n\n      // Only used when projectDiscovery is 'lazy'.\n      const discoverProjects = async (dir: NormalizedPath, data: Directory) => {\n        debug('Searching directory for tsconfig files:', dir)\n        const names = await readdir(dir).catch(() => [])\n\n        await Promise.all(\n          names\n            .filter((name) => configNames.includes(name))\n            .map((name) => {\n              return processConfigFile(dir, name, data)\n            })\n        )\n\n        if (data.projects.length) {\n          sortProjects(data.projects)\n          if (debug.enabled) {\n            debug(\n              `Directory \"${dir}\" contains the following tsconfig files:`,\n              data.projects.map((p) => path.basename(p.tsconfigFile))\n            )\n          }\n        } else {\n          // No projects found. Reduce memory usage with a stand-in.\n          directoryCache.set(dir, emptyDirectory)\n          debug('No tsconfig files found in directory:', dir)\n        }\n      }\n\n      getResolvers = async function* (importer) {\n        let dir = path.normalize(importer)\n\n        const { root } = path.parse(dir)\n\n        while (dir !== (dir = path.dirname(dir)) && dir !== root) {\n          let data = directoryCache.get(dir)\n\n          if (opts.projectDiscovery === 'lazy') {\n            if (!data) {\n              if (shouldSkipDir(path.basename(dir))) {\n                directoryCache.set(dir, emptyDirectory)\n                continue\n              }\n              directoryCache.set(\n                dir,\n                (data = {\n                  projects: [],\n                  lazyDiscovery: null,\n                })\n              )\n            }\n            await (data.lazyDiscovery ??= discoverProjects(dir, data))\n          } else if (!data) {\n            continue\n          }\n\n          for (const project of data.projects) {\n            const resolver = resolversByProject.get(project)\n            if (resolver) {\n              yield resolver\n            }\n          }\n        }\n      }\n    },\n    configureServer(server: Pick<vite.ViteDevServer, 'watcher'>) {\n      watcher = server.watcher\n\n      server.watcher.on('all', (event, file) => {\n        const normalizedFile = path.normalize(file)\n        if (\n          !normalizedFile.endsWith('.json') ||\n          !path.isAbsolute(normalizedFile)\n        ) {\n          return\n        }\n        if (event === 'add') {\n          if (configNames.includes(path.basename(normalizedFile))) {\n            processConfigFile(\n              path.dirname(normalizedFile),\n              path.basename(normalizedFile)\n            ).catch(console.error)\n          }\n        } else if (event === 'change' || event === 'unlink') {\n          invalidateConfigFile(\n            path.dirname(normalizedFile),\n            path.basename(normalizedFile),\n            event\n          )\n        }\n      })\n    },\n    async resolveId(\n      this: Pick<vite.Rollup.PluginContext, 'resolve'>,\n      id: string,\n      importer: string | undefined,\n      options: {}\n    ) {\n      if (!importer) {\n        logFile?.write('emptyImporter', { importer, id })\n        return\n      }\n      if (relativeImportRE.test(id)) {\n        logFile?.write('relativeId', { importer, id })\n        return\n      }\n      if (id.includes('\\0')) {\n        logFile?.write('virtualId', { importer, id })\n        return\n      }\n\n      // Attempt to coerce the importer to a file path. The importer may be\n      // a \"virtual module\" that may not exist in the filesystem, or it may\n      // be derived from a real file.\n      let importerFile = importer\n      if (importer[0] === '\\0') {\n        // Check if the real file path is provided in the query string. For\n        // example, the WXT framework for browser extensions does this.\n        const index = importer.indexOf('?')\n        if (index !== -1) {\n          const query = path.normalize(importer.slice(index + 1))\n          if (path.isAbsolute(query) && fs.existsSync(query)) {\n            debug('Rewriting virtual importer to real file:', importer)\n            importerFile = query\n          } else {\n            logFile?.write('virtualImporter', { importer, id })\n            return\n          }\n        } else {\n          logFile?.write('virtualImporter', { importer, id })\n          return\n        }\n      }\n\n      // For Vite 4 and under, skipSelf needs to be set.\n      const resolveOptions = { ...options, skipSelf: true }\n      const viteResolve: ViteResolve = async (id, importer) =>\n        (await this.resolve(id, importer, resolveOptions))?.id\n\n      for await (const resolveId of getResolvers(importerFile)) {\n        const [resolved, matched] = await resolveId(\n          viteResolve,\n          id,\n          importerFile\n        )\n        if (resolved) {\n          return resolved\n        }\n        if (matched) {\n          // Once a matching resolver is found, stop looking.\n          break\n        }\n      }\n    },\n  } as const\n\n  return plugin satisfies vite.Plugin\n\n  function resolvePathsRootDir(project: Project): string {\n    if (project.result) {\n      const { options } = project.result\n      if (options && typeof options.pathsBasePath === 'string') {\n        return options.pathsBasePath\n      }\n      return path.dirname(project.tsconfigFile)\n    }\n    const baseUrl = project.tsconfig.compilerOptions?.baseUrl\n    if (baseUrl) {\n      return baseUrl\n    }\n    const projectWithPaths = project.extended?.find(\n      (project) => project.tsconfig.compilerOptions?.paths\n    )\n    return path.dirname((projectWithPaths ?? project).tsconfigFile)\n  }\n\n  function createResolver(project: Project): Resolver | null {\n    const configPath = project.tsconfigFile\n    const config = project.tsconfig\n\n    debug('Config loaded:', inspect({ configPath, config }, false, 10, true))\n\n    // Sometimes a tsconfig is not meant to be used for path resolution,\n    // but rather for pointing to other tsconfig files and possibly being\n    // extended by them. This is represented by an explicitly empty \"files\"\n    // array and a missing/empty \"include\" array.\n    if (config.files?.length == 0 && !config.include?.length) {\n      debug(\n        `[!] Skipping \"${configPath}\" as no files can be matched since \"files\" is empty and \"include\" is missing or empty.`\n      )\n      return null\n    }\n\n    const compilerOptions = config.compilerOptions || {}\n    const { baseUrl, paths } = compilerOptions\n\n    type InternalResolver = (\n      viteResolve: ViteResolve,\n      id: string,\n      importer: string\n    ) => Promise<string | undefined>\n\n    const resolveWithBaseUrl: InternalResolver | undefined = baseUrl\n      ? async (viteResolve, id, importer) => {\n          if (id[0] === '/') {\n            return\n          }\n          const absoluteId = join(baseUrl, id)\n          const resolvedId = await viteResolve(absoluteId, importer)\n          if (resolvedId) {\n            logFile?.write('resolvedWithBaseUrl', {\n              importer,\n              id,\n              resolvedId,\n              configPath,\n            })\n            return resolvedId\n          }\n        }\n      : undefined\n\n    let resolveId: InternalResolver\n    if (paths) {\n      const pathsRootDir = resolvePathsRootDir(project)\n      const pathMappings = resolvePathMappings(paths, pathsRootDir)\n\n      const resolveWithPaths: InternalResolver = async (\n        viteResolve,\n        id,\n        importer\n      ) => {\n        const candidates = logFile ? ([] as string[]) : null\n        for (const mapping of pathMappings) {\n          const match = id.match(mapping.pattern)\n          if (!match) {\n            continue\n          }\n          for (let pathTemplate of mapping.paths) {\n            let starCount = 0\n            const mappedId = pathTemplate.replace(/\\*/g, () => {\n              // There may exist more globs in the path template than in\n              // the match pattern. In that case, we reuse the final glob\n              // match.\n              const matchIndex = Math.min(++starCount, match.length - 1)\n              return match[matchIndex]\n            })\n            candidates?.push(mappedId)\n            const resolvedId = await viteResolve(mappedId, importer)\n            if (resolvedId) {\n              logFile?.write('resolvedWithPaths', {\n                importer,\n                id,\n                resolvedId,\n                configPath,\n              })\n              return resolvedId\n            }\n          }\n        }\n        logFile?.write('notFound', {\n          importer,\n          id,\n          candidates,\n          configPath,\n        })\n      }\n\n      if (resolveWithBaseUrl) {\n        resolveId = async (viteResolve, id, importer) =>\n          (await resolveWithPaths(viteResolve, id, importer)) ??\n          (await resolveWithBaseUrl(viteResolve, id, importer))\n      } else {\n        resolveId = resolveWithPaths\n      }\n    } else if (resolveWithBaseUrl) {\n      resolveId = resolveWithBaseUrl\n    } else {\n      debug(`[!] Skipping \"${configPath}\" as no paths or baseUrl are defined.`)\n      return null\n    }\n\n    const configDir = path.normalize(path.dirname(configPath))\n\n    let outDir =\n      compilerOptions.outDir && path.normalize(compilerOptions.outDir)\n\n    // When `tsconfck.parseNative` is used, the outDir is absolute, which\n    // is not what `getIncluder` expects.\n    if (outDir && path.isAbsolute(outDir)) {\n      outDir = path.relative(configDir, outDir)\n    }\n\n    const isIncludedRelative = getIncluder(\n      config.include?.map((p) => ensureRelative(configDir, p)),\n      config.exclude?.map((p) => ensureRelative(configDir, p)),\n      outDir\n    )\n\n    const importerExtRE = opts.loose\n      ? /$/\n      : compilerOptions.allowJs ||\n        path.basename(configPath).startsWith('jsconfig.')\n      ? /\\.(astro|mdx|svelte|vue|[mc]?[jt]sx?)$/\n      : /\\.[mc]?tsx?$/\n\n    const resolutionCache = new Map<string, string>()\n\n    return async (viteResolve, id, importer) => {\n      // Remove query and hash parameters from the importer path.\n      const importerFile = path.normalize(importer.replace(/[#?].+$/, ''))\n\n      // Ignore importers with unsupported extensions.\n      if (!importerExtRE.test(importerFile)) {\n        logFile?.write('unsupportedExtension', { importer, id })\n        return notApplicable\n      }\n\n      // Respect the include/exclude properties.\n      const relativeImporterFile = path.relative(configDir, importerFile)\n      if (!isIncludedRelative(relativeImporterFile)) {\n        logFile?.write('configMismatch', { importer, id, configPath })\n        return notApplicable\n      }\n\n      // Find and remove Vite's suffix (e.g. \"?url\") if present.\n      // If the path is resolved, the suffix will be added back.\n      const suffix = /\\?.+$/.exec(id)?.[0]\n      if (suffix) {\n        id = id.slice(0, -suffix.length)\n      }\n\n      let resolvedId = resolutionCache.get(id)\n      if (resolvedId) {\n        logFile?.write('resolvedFromCache', {\n          importer,\n          id,\n          resolvedId,\n          configPath,\n        })\n      } else {\n        resolvedId = await resolveId(viteResolve, id, importer)\n        if (!resolvedId) {\n          return notFound\n        }\n        resolutionCache.set(id, resolvedId)\n      }\n\n      // Restore the suffix if one was removed earlier.\n      if (suffix) {\n        resolvedId += suffix\n      }\n\n      return [resolvedId, true]\n    }\n  }\n}\n\nconst relativeImportRE = /^\\.\\.?(\\/|$)/\nconst defaultInclude = ['**/*']\nconst defaultExclude = [\n  '**/node_modules',\n  '**/bower_components',\n  '**/jspm_packages',\n]\n\n/**\n * The returned function does not support absolute paths.\n * Be sure to call `path.relative` on your path first.\n */\nfunction getIncluder(\n  includePaths = defaultInclude,\n  excludePaths = defaultExclude,\n  outDir?: string\n) {\n  if (outDir) {\n    excludePaths = excludePaths.concat(outDir)\n  }\n  if (includePaths.length || excludePaths.length) {\n    const includers: RegExp[] = []\n    const excluders: RegExp[] = []\n\n    includePaths.forEach(addCompiledGlob, includers)\n    excludePaths.forEach(addCompiledGlob, excluders)\n\n    if (debug.enabled) {\n      debug(`Compiled tsconfig globs:`, {\n        include: {\n          globs: includePaths,\n          regexes: includers,\n        },\n        exclude: {\n          globs: excludePaths,\n          regexes: excluders,\n        },\n      })\n    }\n\n    return (path: string) => {\n      path = path.replace(/\\?.+$/, '')\n      if (!relativeImportRE.test(path)) {\n        path = './' + path\n      }\n      const test = (glob: RegExp) => glob.test(path)\n      return includers.some(test) && !excluders.some(test)\n    }\n  }\n  return () => true\n}\n\nfunction addCompiledGlob(this: RegExp[], glob: string) {\n  const endsWithGlob = glob.split('/').pop()!.includes('*')\n  const relativeGlob = relativeImportRE.test(glob) ? glob : './' + glob\n  if (endsWithGlob) {\n    this.push(compileGlob(relativeGlob))\n  } else {\n    // Append a globstar to possible directories.\n    this.push(compileGlob(relativeGlob + '/**'))\n\n    // Try to match specific files (must have file extension).\n    if (/\\.\\w+$/.test(glob)) {\n      this.push(compileGlob(relativeGlob))\n    }\n  }\n}\n\nfunction compileGlob(glob: string) {\n  return globRex(glob, {\n    extended: true,\n    globstar: true,\n  }).regex\n}\n\nfunction ensureRelative(dir: string, path: string) {\n  return isAbsolute(path) ? relative(dir, path) : path\n}\n","import createDebug from 'debug'\n\nexport const debug = createDebug('vite-tsconfig-paths')\n\nif (process.env.TEST === 'vite-tsconfig-paths') {\n  createDebug.enable('vite-tsconfig-paths')\n}\n","import { resolve } from 'node:path'\n\nexport type PathMapping = {\n  pattern: RegExp\n  paths: string[]\n}\n\nexport function resolvePathMappings(\n  paths: Record<string, string[]>,\n  base: string\n) {\n  // If a module name can be matched with multiple patterns then pattern\n  // with the longest prefix will be picked.\n  const sortedPatterns = Object.keys(paths).sort(\n    (a: string, b: string) => getPrefixLength(b) - getPrefixLength(a)\n  )\n  const resolved: PathMapping[] = []\n  for (let pattern of sortedPatterns) {\n    const relativePaths = paths[pattern]\n    pattern = escapeStringRegexp(pattern).replace(/\\*/g, '(.+)')\n    resolved.push({\n      pattern: new RegExp('^' + pattern + '$'),\n      paths: relativePaths.map((relativePath) => resolve(base, relativePath)),\n    })\n  }\n  return resolved\n}\n\nfunction getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf('*')\n  return pattern.substr(0, prefixLength).length\n}\n\n// Adapted from:\n// https://github.com/sindresorhus/escape-string-regexp/blob/ba9a4473850cb367936417e97f1f2191b7cc67dd/index.js\n//\n// MIT License\n//\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://\n// sindresorhus.com)\n//\nfunction escapeStringRegexp(string: string) {\n  // Escape characters with special meaning either inside or outside\n  // character sets. Use a simple backslash escape when it’s always\n  // valid, and a `\\xnn` escape when the simpler form would be\n  // disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n}\n","import * as os from 'node:os'\nimport * as path from 'node:path'\nimport * as vite from 'vite'\n\nconst isWindows = os.platform() == 'win32'\n\nexport type NormalizedPath = string & { __normalized: true }\n\nexport const normalize = (p: string): NormalizedPath => {\n  let output = vite.normalizePath(p)\n  // Normalize the drive letter casing on Windows to upper case,\n  if (isWindows && output[1] === ':') {\n    output = output[0].toUpperCase() + output.substring(1)\n  }\n  return output as NormalizedPath\n}\n\nexport const parse: (p: NormalizedPath) => {\n  root: NormalizedPath\n} = path.parse as any\n\nexport const resolve = isWindows\n  ? (...paths: string[]) => normalize(path.win32.resolve(...paths))\n  : (path.posix.resolve as (...paths: string[]) => NormalizedPath)\n\nexport const isAbsolute = isWindows\n  ? path.win32.isAbsolute\n  : path.posix.isAbsolute\n\n/** Only call this on normalized paths */\nexport const join = path.posix.join as (\n  ...paths: NormalizedPath[]\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const relative = path.posix.relative as (\n  from: NormalizedPath,\n  to: NormalizedPath\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const basename = path.posix.basename as (\n  path: NormalizedPath,\n  suffix?: string\n) => NormalizedPath\n\n/** Only call this on normalized paths */\nexport const dirname = path.dirname as (p: NormalizedPath) => NormalizedPath\n","import { createWriteStream, statSync, writeFileSync } from 'node:fs'\nimport { debug } from './debug'\n\ntype ImportDetails = { importer: string | undefined; id: string }\ntype ConfigDetails = ImportDetails & { configPath: string }\ntype ResolveDetails = ConfigDetails & { resolvedId: string }\ntype NotFoundDetails = ConfigDetails & { candidates: string[] | null }\n\nexport type LogEvent =\n  | ['emptyImporter', ImportDetails]\n  | ['virtualImporter', ImportDetails]\n  | ['unsupportedExtension', ImportDetails]\n  | ['relativeId', ImportDetails]\n  | ['virtualId', ImportDetails]\n  | ['resolvedWithBaseUrl', ResolveDetails]\n  | ['resolvedWithPaths', ResolveDetails]\n  | ['resolvedFromCache', ResolveDetails]\n  | ['notFound', NotFoundDetails]\n  | ['configMismatch', ConfigDetails]\n\n/**\n * This log file is dedicated to the resolution process. Other debug logs\n * will appear in the console if you set `DEBUG=vite-tsconfig-paths` in\n * your shell environment.\n */\nexport function createLogFile(logFilePath: string) {\n  let mtime: number | undefined\n  try {\n    mtime = statSync(logFilePath).mtime.getTime()\n  } catch {}\n\n  // Clear the log file if it's older than 10 seconds.\n  if (!mtime || Date.now() - mtime > 10_000) {\n    debug('Clearing log file:', logFilePath)\n    writeFileSync(logFilePath, '')\n  }\n\n  const logFile = createWriteStream(logFilePath, {\n    flags: 'a',\n    encoding: 'utf-8',\n  })\n\n  return {\n    write(...event: LogEvent) {\n      logFile.write(event[0] + ': ' + JSON.stringify(event[1]) + '\\n')\n    },\n  }\n}\n"],"mappings":"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","names":["isAbsolute","join","relative","vite","parse","resolve","dirname","resolve","join","_a","dirname","parse","id","importer","project","path","isAbsolute","relative"]}